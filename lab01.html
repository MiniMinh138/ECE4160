<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta name="description" content="" />
  <meta name="author" content="" />
  <title>Minh Nguyen | ECE 4160 | Fast Robots</title>
  <!-- Favicon-->
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
  <!-- Bootstrap Icons-->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel="stylesheet" />
  <!-- Google fonts-->
  <link href="https://fonts.googleapis.com/css?family=Merriweather+Sans:400,700" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css?family=Merriweather:400,300,300italic,400italic,700,700italic"
    rel="stylesheet" type="text/css" />
  <!-- SimpleLightbox plugin CSS-->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/SimpleLightbox/2.1.0/simpleLightbox.min.css" rel="stylesheet" />
  <!-- Core theme CSS (includes Bootstrap)-->
  <link href="css/styles.css" rel="stylesheet" />
</head>

<body id="page-top">
  <!-- Navigation-->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top py-3" id="mainNav">
    <div class="container px-4 px-lg-5">
      <a class="navbar-brand" href="index.html">ECE 4160 | Fast Robots</a>
      <button class="navbar-toggler navbar-toggler-right" type="button" data-bs-toggle="collapse"
        data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
        aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ms-auto my-2 my-lg-0">
          <li class="nav-item"><a class="nav-link" href="index.html">Back</a></li>
        </ul>
      </div>
    </div>
  </nav>
  <!-- labs-->
  <section class="page-section" id="labs">
    <div class="container px-4 px-lg-5">
      <h2 class="text-center mt-0">Lab 01: The Artemis Board and Bluetooth</h2>
      <hr class="divider" />
      <div class="text-body">
        <div class="Objective">
          <h3 class="h3 mb-2">Objective</h3>
          <p class="text-muted mb-0">The purpose of this lab was to setup and familarize
            ourselves with the Arduino IDE and Artemis board. The first part was to run
            example code from the Artemis library. The second part involved implementing
            and testing Bluetooth with the board. This was done using Python in Jupyter Lab
            and the Arduino IDE.
          </p>
          <hr class="divider divider-light" />
          <h3 class="h3 mb-2">Part 1: Running example files</h3>
          <br>
          <h4 class="h4 mb-2">Prelab</h4>
          <p class="text-muted mb-0">The prelab involved installing the Arduino IDE
            and downloading the correct libraries for the SparkFun RedBoard Artemis Nano.
          </p>
          <br>
          <h4 class="h4 mb-2">Lab Tasks</h4>
          <p class="text-muted mb-0">The lab tasks were to run 4 different example sketches (code blocks).
          </p>
          <br>
          <h5 class="h5 mb-2">Task 1: Blink it Up</h5>
          <p class="text-muted mb-0">This example has the microcontroller blinking an LED on and off in 1 second
            intervals.
          </p>
          <iframe width="560" height="315" src="https://www.youtube.com/embed/ev-oexgACRY?si=4bo7mZuNXp2SUyHl"
            title="YouTube video player" frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowfullscreen></iframe>
          <br>
          <h5 class="h5 mb-2">Task 2: Serial</h5>
          <p class="text-muted mb-0">This example had the serial monitor echo whatever you typed in the message.
          </p>
          <iframe width="560" height="315" src="https://www.youtube.com/embed/uGJ7Yp0MuDk?si=H_RAgVLif4jMwY9U"
            title="YouTube video player" frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowfullscreen></iframe>
          <br>
          <h5 class="h5 mb-2">Task 3: AnalogRead</h5>
          <p class="text-muted mb-0">This example had a variety of data printing from the microcontroller, but we were
            focused on the temperature reading. We changed the temperature by holding the board to heat it up.
          </p>
          <iframe width="560" height="315" src="https://www.youtube.com/embed/9_UImX9XPjY?si=2NxPSKR2bYsUgruO"
            title="YouTube video player" frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowfullscreen></iframe>
          <br>
          <h5 class="h5 mb-2">Task 4: MicrophoneOutput</h5>
          <p class="text-muted mb-0">This example had the microphone measure the frequency of a noise. The noise in this
            case was whistling.
          </p>
          <iframe width="560" height="315" src="https://www.youtube.com/embed/9vxM09PIwnU?si=MClHCrOe_r7h9Ao_"
            title="YouTube video player" frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
            allowfullscreen></iframe>
          <hr class="divider divider-light" />
          <h3 class="h3 mb-2">Part 2: Bluetooth</h3>
          <br>
          <h4 class="h4 mb-2">Prelab</h4>
          <p class="text-muted mb-0">The prelab setup involved installing the proper software and packages
            to interface with the RedBoard. We had to install Python 3 and pip. Next, we had to set up a virtual
            environment. We started by installing venv:
          </p>
          <br>
          <code>python3 -m pip install --user virtualenv</code>
          <br>
          <br>
          <p class="text-muted mb-0">Then, navigating to a project directory that we created, we create the virtual
            environment (venv):</p>
          <br>
          <code>python3 -m venv FastRobots_ble</code>
          <br>
          <br>
          <p class="text-muted mb-0">We would activate or deactivate the venv with these lines,
            respectively:
          </p>
          <br>
          <code>source FastRobots_ble/bin/activate</code>
          <br>
          <code>deactivate</code>
          <br>
          <br>
          <p class="text-muted mb-0">With the venv active, we installed the necessary packages:</p>
          <br>
          <code>pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab</code>
          <br>
          <br>
          <p class="text-muted mb-0">Finally, to run the jupyter lab, we used this line:</p>
          <br>
          <code>jupyter lab</code>
          <br>
          <br>
          <h4 class="h4 mb-2">Codebase</h4>
          <p class="text-muted mb-0">The codebase is separated into 2 parts, the arduino code which commands the
            microcontroller and the python code which interfaces with the microcontroller from a laptop/pc. The code
            sets up both the laptop and the microcontroller as a receiver and a transmitter to have a 2 way connection.
          </p>
          <p class="text-muted mb-0">The arduino code sets up the Bluetooth service using BLEService which initializes
            Bluetooth connectivity with a unique id as input. The BLEService is comprised of BLExCharacteristics which
            define how different types of data (string, int, float) are handled by the microcontroller. There are a host
            of functions the microcontroller can do such as write values and read values. These functionalities can be
            modified and leveraged by writing custom commands. It is important to note that these custom commands must
            be defined on both the microcontroller and laptop/pc side. The commands are read in via the bluetooth
            connection and parsed to complete the correct functionality.</p>
          <p class="text-muted mb-0">The python code sets up the Bluetooth service on the laptop side. It's connection
            to the microcontroller is defined by its <code>connection.yaml</code> file which defines the artemis address
            (MAC address of the microcontroller), the unique id inputted into BLEService, and the unique ideas for each
            characteristic defined on the arduino side. This file allows the two to communicate with each other. The
            python code includes a variety of functions to send commands and accompanying data to the microcontroller.
          </p>
          <br>
          <h4 class="h4 mb-2">Lab Tasks</h4>
          <p class="text-muted mb-0">The main tasks of this lab was to set up Bluetooth connectivity and then write a
            host of functions to test the communication between the microcontroller and laptop. The first step was
            establishing a connection. (Note: the photos with a light background are from the laptop code and the dark
            background is the arduino code)</p>
          <br>
          <h5 class="h5 mb-2">Task 0: Establishing Connection</h5>
          <p class="text-muted mb-0">To establish the connection, first we had to get the MAC address of the
            microcontroller by running the <code>ble_arduino.ino</code> file which printed the MAC address. We then
            replaced the <code>artemis_address</code> in the <code>connection.yaml</code> file in the python code. Next,
            we generated a uuid in the jupyter notebook using:
            <br>
            <code>from uuid import uuid4 <br>
            uuid4()</code>
            <br>
            This generated a uuid that we placed in the <code>connection.yaml</code> file and the
            <code>BLE_UUID_TEST_SERVICE</code> in the <code>ble_arduino.ino</code> file.
            <br>
            <img src="assets/Lab1/mac-address.png" alt="MAC Address">
            <img src="assets/Lab1/connection.png" alt="connection.yaml">
            <img src="assets/Lab1/arduino-uuid.png" alt="arduino-uuid.yaml">
            <br>
            After burning the sketch onto
            the microcontroller and running the demo code in the jupyter notebook, we were able to establish a
            connection.
          </p>
          <img src="assets/Lab1/connected.png" alt="Established Connection">
          <br>
          <br>
          <h5 class="h5 mb-2">Task 1: ECHO</h5>
          <p class="text-muted mb-0">The 1st task was to implement the ECHO command. This basically takes a string from
            the
            laptop side, sends it to the microcontroller, the microcontroller modifies the string, and then sends it
            back to the laptop.
          </p>
          <p class="text-muted mb-0">On the laptop side, we just send the command and receive the string.</p>
          <img src="assets/Lab1/python-echo.png" alt="Python ECHO">
          <br>
          <p class="text-muted mb-0">We implement the modification in the arduino file.</p>
          <img src="assets/Lab1/arduino-echo.png" alt="Arduino ECHO">
          <br>
          <p class="text-muted mb-0">It is important to note that whenever a new command is created, we define it in
            both the python and arduino files.</p>
          <img src="assets/Lab1/python-commands.png" alt="Python Commands">
          <img src="assets/Lab1/arduino-commands.png" alt="Arduino Commands">
          <br>
          <br>
          <h5 class="h5 mb-2">Task 2: GET_TIME_MILLIS</h5>
          <p class="text-muted mb-0">The 2nd task was similar to the first, but this function takes in no input data
            from the laptop side and simply gets the current time in milliseconds from the microcontroller in a
            formatted string.
          </p>
          <img src="assets/Lab1/python-millis.png" alt="Python Millis">
          <img src="assets/Lab1/arduino-millis.png" alt="Arduino Millis">
          <br>
          <br>
          <h5 class="h5 mb-2">Task 3: Notification Handler</h5>
          <p class="text-muted mb-0">The 3rd task was to set up a notification handler that handles any received data
            from the laptop side sent from the microcontroller. Without notify, you would need to explicitly receive the
            data using one of the <code>ble.receive[datatype]</code> functions.</p>
          <img src="assets/Lab1/python-handler.png" alt="Python Notification Handler">
          <br>
          <br>
          <h5 class="h5 mb-2">Task 4: Constant Polling of Time</h5>
          <p class="text-muted mb-0">The 4th task was to have the microcontroller constantly send time data to the
            laptop and have the laptop notification handler process the time data. The purpose of this task was to see
            how fast messages could be sent if they were sent in succession by the microcontroller.</p>
          <p class="text-muted mb-0">To implement this, decided to add the time polling in the main loop of the
            microcontroller which runs when it is connected via bluetooth.
            <br>
            <img src="assets/Lab1/arduino-t4.png" alt="Arduino Loop">
            <br>
            <br>
            We created a flag variable to start and stop the recording and made the corresponding commands.
            <br>
            <img src="assets/Lab1/arduino-start-stop-t4.png" alt="Arduino Start/Stop">
            <br>
            <br>
            On the laptop side, we just ran the Start or Stop command and had the notification handler print out the
            time stamps.
            <br>
            <img src="assets/Lab1/python-t4.png" alt="Python Receive Polling Time Data">
            <br>
            <br>
            Here we see that there seems to be a delay between a few of the time data points sent. As a rough estimate,
            we see that 2-3 consecutive time data points are sent before there is a lag. Taking the first 30 sent data
            points, we see that the data points were sent over a period of 226ms. This gives an average data transfer
            rate of
            1msg/7.53ms.
          </p>
          <br>
          <h5 class="h5 mb-2">Task 5: SEND_TIME_DATA</h5>
          <p class="text-muted mb-0">The 5th task was a modification the 4th task. Instead of constantly sending time
            data, the microcontroller would still constantly generate time data, but it would store the data in an
            array.
            <br>
            When the
            array filled up, we decided to simply stop recording time stamps. We made it so that the array is "reset"
            every time we call the START command (by setting counter = 0) to signify the start of a new stream of time
            data. We did this to
            simplify the array usage. In the future, we could add a message that let's the laptop know when the array is
            filled as well.
            <br>
            <img src="assets/Lab1/arduino-time-loop.png" alt="Arduino Time Loop">
            <br>
            <br>
            We then created a function <code>SEND_TIME_DATA</code> that would send that array of data.
            <br>
            <img src="assets/Lab1/arduino-send-time-data.png" alt="Arduino Send Time Data">
            <br>
            <br>
            We then run the commands on the laptop to record and send the data.
            <br>
            <img src="assets/Lab1/python-time-loop.png" alt="Python Receive Collected Data">
            <br>
            <br>
            Performing a similar analysis to Task 4 with the 30 data points, we see that they were sent over a period of
            13ms. This gives an average data transfer rate of 1msg/0.43ms.


          </p>
          <br>
          <h5 class="h5 mb-2">Task 6: GET_TEMP_READINGS</h5>
          <p class="text-muted mb-0">The 6th task was an extension of the 5th task where we would generate an array of
            corresponding
            temperature readings (in Fahrenheit) in parallel with the time data. We then created the
            <code>GET_TEMP_READINGS</code> function to send both the temperature and time data. It was important to
            ensure that each data point had the temperature and the corresponding time. The loop is the same loop as the
            picture in Task 5. The GET_TEMP_READINGS function is defined here. It is very similar to SEND_TIME_DATA.
            <br>
            <img src="assets/Lab1/arduino-get-temps.png" alt="Arduino Get Temps">
            <br>
            <br>
            The results when calling this function on the laptop are as such.
            <br>
            <img src="assets/Lab1/python-temp.png" alt="Python Temp + Time">
          </p>
          <br>
          <h5 class="h5 mb-2">Task 7: Efficiency of Task 4 vs. Task 5</h5>
          <p class="text-muted mb-0">Task 4 collects the time data and tries to send it immediately while Task 5
            collects it "in the background" and waits to send it. They two methods have their own trade offs. Task 4's
            methodology is important for when you need a constant flow of updated readings whereas Task 5 would struggle
            with that as a command needs to be called to receive the data (calling this command repeatedly to try to
            mimic Task 4's behavior is ill advised because of the inefficiencies of the array storage method and
            traversing it). On the other hand, Task 5's method allows for a faster transfer rate which means that the
            data can be processed by the laptop at a faster rate as long as you don't need a constant stream of new
            data.
            <br>
            <br>
            If the Artemis board has 385 kB of RAM and assuming we are using Task 5's methodology, we can calculate how
            much data can be stored without running out of memory(ignoring the RAM taken up by other functions on the
            board). If we assume each data point is 16-bits and the microcontroller runs at 150 Hz (150 cycles/second),
            we consume 2400 bits/second. 385 kB = 3,080,000 bits. Dividing this by the rate that we consume, we get
            1283.3 seconds. So we can store 1283.3 seconds worth of data before we run out of memory.
          </p>
          <br>
          <h3 class="h3 mb-2">Discussion</h3>
          <p class="text-muted mb-0">I've learned a basic use of the BLE library. This will allow me to gather sensor
            data and transfer it in future labs. It has also showed me the pros/cons of constantly polling data vs.
            storing it to send. The only notably challenge was picking a design for the looping method to gather the
            time data.</p>



        </div>
      </div>
    </div>
  </section>

  <!-- Footer-->
  <footer class="bg-light py-5">
    <div class="container px-4 px-lg-5">
      <div class="small text-center text-muted">Copyright &copy; 2023 - Company Name</div>
    </div>
  </footer>
  <!-- Bootstrap core JS-->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  <!-- SimpleLightbox plugin JS-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/SimpleLightbox/2.1.0/simpleLightbox.min.js"></script>
  <!-- Core theme JS-->
  <script src="js/scripts.js"></script>
  <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
  <!-- * *                               SB Forms JS                               * *-->
  <!-- * * Activate your form at https://startbootstrap.com/solution/contact-forms * *-->
  <!-- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *-->
  <script src="https://cdn.startbootstrap.com/sb-forms-latest.js"></script>
</body>

</html>